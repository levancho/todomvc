import com.azure.ai.openai.OpenAIClient;
import com.azure.ai.openai.models.ChatCompletionsOptions;
import com.azure.ai.openai.models.ChatMessage;
import com.azure.ai.openai.models.ChatRole;
import com.azure.core.credential.AzureKeyCredential;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.Stream;

import reactor.core.publisher.Flux;

@RestController
public class ChatCompletionController {

    // Initialize the Azure OpenAI client with your credentials
    private final OpenAIClient openAIClient = new OpenAIClient.Builder()
            .credential(new AzureKeyCredential("your-azure-api-key"))
            .endpoint("https://your-resource-name.openai.azure.com/")
            .buildClient();

    private final ExecutorService executor = Executors.newSingleThreadExecutor();

    @GetMapping(value = "/chat-stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> streamChatCompletion() {
        return Flux.create(sink -> {
            executor.submit(() -> {
                try {
                    // Prepare your chat messages
                    List<ChatMessage> chatMessages = new ArrayList<>();
                    chatMessages.add(new ChatMessage(ChatRole.SYSTEM).setContent("You are a helpful assistant."));
                    chatMessages.add(new ChatMessage(ChatRole.USER).setContent("Hello, how can I use Azure OpenAI?"));

                    // Set up chat completion options
                    ChatCompletionsOptions options = new ChatCompletionsOptions(chatMessages);

                    // Start the streaming process (Pseudo-code, replace with your SDK's streaming implementation)
                    openAIClient.streamChatCompletion("deploymentName", "gpt-35-turbo", "0301", options, completion -> {
                        // Simulate streaming behavior
                        String chunk = completion.getMessage().getContent(); // get each generated chunk
                        sink.next("Assistant: " + chunk);
                        
                        try {
                            // Simulate a streaming delay
                            TimeUnit.MILLISECONDS.sleep(500);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    });

                    // Complete the stream
                    sink.complete();
                } catch (Exception e) {
                    sink.error(e);
                }
            });
        });
    }
}

InputStream inputStream = new ByteArrayInputStream(messageContent.getBytes(StandardCharsets.UTF_8));

